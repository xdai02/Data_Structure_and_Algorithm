5.1 AVL树

**AVL树**

<img src="./img/C5/5-1/1.png" style="zoom: 60%;" />

<img src="./img/C5/5-1/2.png" style="zoom: 60%;" />

<img src="./img/C5/5-1/3.png" style="zoom: 60%;" />

AVL树的命名是取自两位发明者的首字母`G. M. Adelson-Velsky`和`E. M. Landis`，AVL树也称为平衡二叉树。

AVL树能够调整自身的平衡性，AVL树遵循高度平衡，任何结点的两个子树高度差不会超过`1`。

对于AVL树的每一个结点，平衡因子（balance factor）是它左子树高度和右子树高度的差值。只有当二叉树所有结点的平衡因子都是`-1`、`0`、`1`这三个值时，这棵树才是一个合格的AVL树。

![](./img/C5/5-1/4.png)



**失衡调整**

当AVL树插入或删除结点时，平衡有可能被打破。

![](./img/C5/5-1/5.png)

通过对AVL树进行`左旋转`、`右旋转`的操作，就能使其重新恢复平衡。

1. 左旋转：`逆时针`旋转AVL树的两个结点X和Y，使得父结点被自己的右孩子取代，而自己成为左孩子。

![](./img/C5/5-1/6.png)

2. 右旋转：`顺时针`旋转AVL树的两个结点X和Y，使得父结点被自己的左孩子取代，而自己成为右孩子。

![](./img/C5/5-1/7.png)

AVL树的失衡调整可以分为四种情况：

1. 左左局面（LL）：右旋转

![](./img/C5/5-1/8.png)

---

【代码】LL旋转

```c
static AVLNode* LLRotation(AVLTree *k2) {
    AVLTree *k1 = k2->left;
    k2->left = k1->right;
    k1->right = k2;
    
    k2->height = max(height(k2->left), height(k2->right)) + 1;
    k1->height = max(height(k1->left), k2->height) + 1;
    return k1;
}
```

---

2. 右右局面（RR）：左旋转

![](./img/C5/5-1/9.png)

---

【代码】RR旋转

```c
static AVLNode* RRRotation(AVLTree *k1) {
    AVLTree *k2 = k1->right;
    k1->right = k2->left;
    k2->left = k1;

    k1->height = max(height(k1->left), height(k1->right)) + 1;
    k2->height = max(k1->height, height(k2->right)) + 1;
    return k2;
}
```

---

3. 左右局面（LR）：先左旋转、再右旋转

![](./img/C5/5-1/10.png)

---

【代码】LR旋转

```c
static AVLNode* LRRotation(AVLTree *k3) {
    k3->left = RRRotation(k3->left);
    return LLRotation(k3);
}
```

---

4. 右左局面（RL）：先右旋转、再左旋转

![](./img/C5/5-1/11.png)

---

【代码】RL旋转

```c
static AVLNode* RLRotation(AVLTree *k1) {
    k1->right = LLRotation(k1->right);
    return RRRotation(k1);
}
```

---

例如依次向AVL树添加结点：3, 2, 1, 4, 5, 6, 7, 16, 15, 14, 13, 12, 11, 10, 8, 9。

![](./img/C5/5-1/12.png)

![](./img/C5/5-1/13.png)

![](./img/C5/5-1/14.png)

![](./img/C5/5-1/15.png)

![](./img/C5/5-1/16.png)

![](./img/C5/5-1/17.png)

![](./img/C5/5-1/18.png)

![](./img/C5/5-1/19.png)

![](./img/C5/5-1/20.png)

![](./img/C5/5-1/21.png)

![](./img/C5/5-1/22.png)

![](./img/C5/5-1/23.png)

![](./img/C5/5-1/24.png)

![](./img/C5/5-1/25.png)

![](./img/C5/5-1/26.png)

---

【代码】插入结点

```c
AVLNode* insert(AVLTree *tree, dataType val) {
    if(!tree) {
        tree = createNode(val, NULL, NULL);
        tree->height = 1;
        return tree;
    }

    if(val < tree->data) {
        tree->left = insert(tree->left, val);
        if(height(tree->left) - height(tree->right) == 2) {
            if(val < tree->left->data) {
                tree = LLRotation(tree);
            } else {
                tree = LRRotation(tree);
            }
        }
    } else {
        tree->right = insert(tree->right, val);
        if(height(tree->right) - height(tree->left) == 2) {
            if(val > tree->right->data) {
                tree = RRRotation(tree);
            } else {
                tree = RLRotation(tree);
            }
        }
    }

    tree->height = max(height(tree->left), height(tree->right)) + 1;
    return tree;
}
```

---

【代码】删除结点

```c
static AVLNode* deleteNode(AVLTree *tree, AVLNode *del) {
    if(!tree || !del) {
        return NULL;
    }

    if(del->data < tree->data) {
        tree->left = deleteNode(tree->left, del);
        if(height(tree->right) - height(tree->left) == 2) {
            AVLNode *rightNode = tree->right;
            if(height(rightNode->left) > height(rightNode->right)) {
                tree = RLRotation(tree);
            } else {
                tree = RRRotation(tree);
            }
        }
    } else if(del->data > tree->data) {
        tree->right = deleteNode(tree->right, del);
        if(height(tree->left) - height(tree->right) == 2) {
            AVLNode *leftNode = tree->left;
            if(height(leftNode->right) > height(leftNode->left)) {
                tree = LRRotation(tree);
            } else {
                tree = LLRotation(tree);
            }
        }
    } else {
        if(tree->left && tree->right) {
            if(height(tree->left) > height(tree->right)) {
                // 如果左子树比右子树高：
                // 1. 找出左子树的最大结点
                // 2. 将最大结点的值赋给tree
                // 3. 删除最大结点
                AVLNode *max = getMax(tree->left);
                tree->data = max->data;
                tree->left = deleteNode(tree->left, max);
            } else {
                // 如果右子树比左子树高（或相等）：
                // 1. 找出右子树的最小结点
                // 2. 将最小结点的值赋给tree
                // 3. 删除最小结点
                AVLNode *min = getMin(tree->right);
                tree->data = min->data;
                tree->right = deleteNode(tree->right, min);
            }
        } else {
            AVLNode *temp = tree;
            tree = tree->left ? tree->left : tree->right;
            free(temp);
        }
    }
    return tree;
}
```

---

<div style="page-break-after: always;"></div>

## 5.2 伸展树

**伸展树（Splay Tree）**

为了维持二叉搜索树的高效率查找，就需要对二叉搜索树进行平衡调整。著名的AVL树和红黑树就是典型的自平衡二叉搜索树。

伸展树是一种相当奇特的树，它不需要平衡因子、颜色等信息，甚至它没有时刻维护全树的平衡状态，却仍然能保持各项操作达到均摊为$ O(logn) $。

伸展树考虑到局部性原理（刚被访问的内容下次可能仍会被访问，查找次数多的内容下一次仍可能被访问），为了使整体查找时间更小，被查频率高的结点应该处于靠近树根的位置。

伸展树的核心是每次查找结点后对树进行重构，把被查找结点旋转到根结点，伸展树的旋转操作沿用了AVL树中的旋转方式。

![](./img/C5/5-2/1.png)

![](./img/C5/5-2/2.png)

![](./img/C5/5-2/3.png)

![](./img/C5/5-2/4.png)

<div style="page-break-after: always;"></div>

## 5.3 红黑树

**红黑树（Red Black Tree）**

<img src="./img/C5/5-3/1.png" style="zoom:80%;" />

1. 结点是红色或黑色的。
2. 根结点是黑色的。
3. 叶子结点都是黑色的空结点`NIL`。
4. 红色结点的两个子结点都是黑色的，即从叶子到根的所有路径上不能有连续的两个红色结点。
5. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

![](./img/C5/5-3/2.png)

<img src="./img/C5/5-3/3.png" style="zoom:80%;" />

<img src="./img/C5/5-3/4.png" style="zoom:80%;" />

<img src="./img/C5/5-3/5.png" style="zoom:80%;" />

<img src="./img/C5/5-3/6.png" style="zoom:80%;" />

例如向红黑树中插入新结点14，由于父结点15是黑色结点，这种情况不会破坏红黑树的规则，无需做任何调整。

![](./img/C5/5-3/7.png)

向红黑树中插入新结点21，由于父结点22是红色结点，这种情况打破了红黑树的规则4（红色结点的两个子结点都是黑色的），因此必须进行调整，使其重新符合红黑树的规则。

![](./img/C5/5-3/8.png)

<img src="./img/C5/5-3/9.png" style="zoom:80%;" />



**变色**

为了重新符合红黑树的规则，有时需要把红色结点变为黑色，或是把黑色结点变为红色。

例如对于红黑树的一部分（子树），新插入的结点Y是红色结点，它的父结点X也是红色结点，不符合规则4（红色结点的两个子结点都是黑色的），因此可以把结点X变为黑色。

![](./img/C5/5-3/10.png)

但是，如果这是简单的把一个结点变色，会导致相关路径凭空多出一个黑色结点，这样就会打破规则5（从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点），因此还需要其它的调整策略。



**旋转**

旋转分为左旋转和右旋转。

左旋转就是逆时针旋转红黑树的两个结点，使得父结点被自己的右孩子取代，而自己称为右孩子的左孩子。

![](./img/C5/5-3/11.png)

右旋转就是顺时针旋转红黑树的两个结点，使得父结点被自己的左孩子取代，而自己称为左孩子的右孩子。

![](./img/C5/5-3/12.png)

<img src="./img/C5/5-3/13.png" style="zoom:80%;" />



**插入结点**

<img src="./img/C5/5-3/14.png" style="zoom:80%;" />

1. 局面1：新结点（A）位于树根，没有父结点。这种局面，直接让新结点变色为黑色，规则2（根结点是黑色的）满足。同时黑色的根结点使每条路径上的黑色结点数目都增加了1，因此并没有打破规则5（从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点）。

<img src="./img/C5/5-3/15.png" style="zoom: 67%;" />

2. 局面2：新结点（B）的父结点是黑色的。新插入的红色结点B并没有打破规则，无需调整。

<img src="./img/C5/5-3/16.png" style="zoom:80%;" />

3. 局面3：新结点（D）的父结点和叔叔结点都是红色。这种局面，两个红色结点B和D连续，违反了规则4（红色结点的两个子结点都是黑色的），因此需要先让结点B变为黑色。

![](./img/C5/5-3/17.png)

但是这样一来，结点B所在路径凭空多出了一个黑色结点，打破了规则5（从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点），因此再让结点A变为红色。

![](./img/C5/5-3/18.png)

这时结点A和C又成为了连续的红色结点，再将结点C变为黑色。

![](./img/C5/5-3/19.png)

经过以上调整后，再次符合了红黑树的规则。

4. 局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点是祖父结点的左孩子。

这个局面可以以结点B为轴，做一次左旋转，使得新结点D成为父结点，结点B成为D的左孩子。这样一来进入了局面5。

![](./img/C5/5-3/20.png)

5. 局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点是祖父结点的左孩子。

这一局面可以以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为B的右孩子。

![](./img/C5/5-3/21.png)

再将结点B变为黑色，结点A变为红色。

![](./img/C5/5-3/22.png)

经过以上调整后，再次符合了红黑树的规则。

红黑树的插入操作设计到这5种局面。如果局面4中父结点B是右孩子，则成为了局面5的镜像，原本的右旋转改为左旋转；如果局面5中父结点B是右孩子，则成为了局面4的镜像，原本的左旋转改为右旋转。

<img src="./img/C5/5-3/23.png" style="zoom: 67%;" />

<img src="./img/C5/5-3/24.png" style="zoom: 67%;" />

<img src="./img/C5/5-3/25.png" style="zoom:80%;" />

新结点21和它的父结点22是连续的红色结点，违背了规则4。当前情况符合局面3（新结点的父结点和叔叔结点都是红色）。于是经过三次变色，22变为黑色，25变为红色，27变为黑色，将以结点25为根的子树符合了红黑树的规则。

![](./img/C5/5-3/27.png)

但结点25和结点17成为了连续的红色结点，违背了规则4。于是可以将结点25看做一个新结点，当前正好符合局面5的镜像（新结点的父结点是红色，叔叔是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点是祖父结点的右孩子）。因此可以以根结点13为轴进行左旋转，使得结点17成为新的根结点。

再让结点17变为黑色，13变为红色，使红黑树重新符合规则。

![](./img/C5/5-3/28.png)

<img src="./img/C5/5-3/29.png" style="zoom:80%;" />

<img src="./img/C5/5-3/30.png" style="zoom:80%;" />



**二叉查找树删除结点**

<img src="./img/C5/5-3/31.png" style="zoom:80%;" />

二叉查找树的删除可分为三种情况：

1. 待删除的结点没有子节点：直接删除即可。

<img src="./img/C5/5-3/32.png" style="zoom:80%;" />

2. 待删除结点只有一个孩子：让孩子取代待删除结点。

<img src="./img/C5/5-3/33.png" style="zoom:80%;" />

<img src="./img/C5/5-3/34.png" style="zoom:80%;" />

3. 待删除结点有两个孩子：选择仅小于或仅大于待删除结点的结点取代，习惯上更多地会选择仅大于待删除结点的结点。

<img src="./img/C5/5-3/35.png" style="zoom:80%;" />

<img src="./img/C5/5-3/36.png" style="zoom:80%;" />

<img src="./img/C5/5-3/37.png" style="zoom:80%;" />



**红黑树删除结点**

<img src="./img/C5/5-3/38.png" style="zoom:80%;" />

1. 第一步：如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。

例如删除结点8，因为结点8有两个孩子，可以选择仅大于8的结点10复制到8的位置，结点颜色变成待删除结点的颜色。

<img src="./img/C5/5-3/39.png" style="zoom: 67%;" />

<img src="./img/C5/5-3/40.png" style="zoom:80%;" />

<img src="./img/C5/5-3/41.png" style="zoom:80%;" />

结点10能成为仅大于8的结点，必定没有左孩子结点，所以问题转换成了待删除结点只有一个右孩子（或者没有孩子）的情况。

2. 第二步：根据待删除结点和其唯一子结点的颜色，分情况处理。
- 情况1：自身是红色，子结点是黑色。直接按照二叉查找树的删除操作，删除结点1即可。

<img src="./img/C5/5-3/42.png" style="zoom:80%;" />

- 情况2：自身是黑色，子结点是红色。按照二叉查找树的删除操作，删除结点1。此时这条路径凭空少了一个黑色结点，因此需要将结点2变成黑色即可。

<img src="./img/C5/5-3/43.png" style="zoom:80%;" />

<img src="./img/C5/5-3/44.png" style="zoom:80%;" />

- 情况3：自身是黑色，子结点也是黑色，或者子结点是空叶子结点。这种情况最为复杂，涉及到很多变化。首先还是按照二叉查找树的删除操作，删除结点1。此时这条路径凭空少了一个黑色结点，而且并不能改变结点2的颜色来解决问题。这时需要进入第三步，专门解决父子双黑的情况。

<img src="./img/C5/5-3/45.png" style="zoom:80%;" />

3. 第三步：遇到双黑结点，在子结点顶替父结点后，可分为6种情况处理。

- 情况1：结点2是红黑树的根。此时所有路径都减少了一个黑色结点，并未打破规则，无需调整。

![](./img/C5/5-3/46.png)

- 情况2：结点2的父亲、兄弟、侄子结点都是黑色。

<img src="./img/C5/5-3/47.png" style="zoom:80%;" />

直接把结点2的兄弟结点变为红色。

<img src="./img/C5/5-3/48.png" style="zoom:80%;" />

这样结点B所在路径少了一个黑色结点，两边扯平了。

- 情况3：结点2的兄弟结点是红色。

<img src="./img/C5/5-3/49.png" style="zoom:80%;" />

以结点2的父结点A为轴进行左旋转。

<img src="./img/C5/5-3/50.png" style="zoom:80%;" />

然后结点A变为红色，结点B变为黑色。

<img src="./img/C5/5-3/51.png" style="zoom:80%;" />

这样的变化就有可能转换成情况4、5、6中的任意一种。

- 情况4：结点2的父结点是红色，兄弟和侄子结点是黑色。

<img src="./img/C5/5-3/52.png" style="zoom:80%;" />

将结点2的父结点A变为黑色，兄弟结点B变为红色。

<img src="./img/C5/5-3/53.png" style="zoom:80%;" />

这样结点2的路径补充了黑色结点，而结点B的路径并没有减少黑色结点，重新符合红黑树的规则。

- 情况5：结点2的父结点随意，兄弟结点B是黑色右孩子，结点2的左侄子是红色，右侄子是黑色。

<img src="./img/C5/5-3/54.png" style="zoom:80%;" />

以结点2的兄弟结点B为轴进行右旋转。

<img src="./img/C5/5-3/55.png" style="zoom:80%;" />

将结点B变为红色，结点C变为黑色。

<img src="./img/C5/5-3/56.png" style="zoom:80%;" />

这样的变化就转换成了情况6。

- 情况6：结点2的父结点随意，兄弟结点B是黑色右孩子，结点2的右侄子的红色。

<img src="./img/C5/5-3/57.png" style="zoom:80%;" />

以结点2的父结点A为轴进行左旋转。

<img src="./img/C5/5-3/58.png" style="zoom:80%;" />

将结点A和B的颜色交换，让结点D变为黑色。

<img src="./img/C5/5-3/59.png" style="zoom:80%;" />

这样经过结点2的路径由之前的`随机 + 黑`变成了`随机 + 黑 + 黑`，补充了一个黑色结点。

经过结点D的路径由之前的`随机 + 黑 + 红`变成了`随机 + 黑`，黑色结点并没有减少。

这时重新符合了红黑树的规则。

<img src="./img/C5/5-3/60.png" style="zoom:80%;" />

<img src="./img/C5/5-3/61.png" style="zoom:80%;" />

![](./img/C5/5-3/62.png)

由于待删除结点17有两个孩子，子树当中仅大于17的结点是25，所以把结点25复制到17的位置，保持黑色。

![](./img/C5/5-3/63.png)

接着需要删除原本的结点25，这个情况对应的是删除结点操作中的第二步情况3（待删除结点是黑色，子结点是空叶子结点）。

![](./img/C5/5-3/64.png)

此时，以结点25为根的子树符合第三步情况5的镜像（结点NIL的父结点随意，兄弟结点15是黑色左孩子，结点NIL的右侄子是红色，左侄子是黑色）。

![](./img/C5/5-3/65.png)

通过左旋转和变色，将子树转化成第三步情况6的镜像（结点NIL的父结点随意，兄弟结点16是黑色左孩子，结点NIL的左侄子是红色）。

![](./img/C5/5-3/66.png)

通过右旋转和变色，使整棵二叉树重新符合红黑树的规则。

![](./img/C5/5-3/67.png)

<img src="./img/C5/5-3/68.png" style="zoom: 67%;" />

<img src="./img/C5/5-3/69.png" style="zoom: 67%;" />

<img src="./img/C5/5-3/70.png" style="zoom: 67%;" />

<div style="page-break-after: always;"></div>

## 5.4 Trie树

**Trie树**

`Trie`树的名字取自`检索retrieval`，发音同`tree`，但为了防止误解，也可发音为`try`。

`Trie`树也称`字典树`或`前缀树`，因此它专门用于处理字符串的匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。

<img src="./img/C5/5-4/1.png" style="zoom: 67%;" />

`Trie`树的核心思想就是利用空间换时间，通过最大限度地减少无谓的字符串比较，做到高效查询和插入，时间复杂度为$ O(k) $，$ k $为字符串长度，缺点是如果大量字符串没有公共前缀时会消耗大量内存。

`Trie`树的根结点不包含字符，除根结点外每一个结点都只包含一个字符。从根结点到某一结点，路径上经过的字符连接起来，就为该结点对应的字符串。

`Trie`树在实现过程中，会在结点中设置一个标志，用来表示该结点是否是一个字符串的结尾。



**查询**

在`Trie`树中查找一个字符串时，可以将待查找字符串分割成单个字符，从根结点开始匹配。

![](./img/C5/5-4/2.png)

`Trie`树可以用于前缀匹配，也就是找出一个字符串集合中所有指定前缀的字符串。例如在进行搜索时，可以根据用户输入返回前缀匹配的搜索结果。

![](./img/C5/5-4/3.png)



**插入与删除**

`Trie`树的插入操作就是将字符串的每个字符逐一插入，插入前先判断字符对应结点是否存在，存在则共享结点，不存在则创建新结点。当字符串插入`Trie`树后，将该字符串最后一个字符所对应的结点中设置标志位，表示该字符为该路径上某一字符串的末尾。

![](./img/C5/5-4/4.png)

`Trie`树的删除操作分为3种情况：

1. 删除整个字符串。例如删除`hi`，从树根找到结点`h`，再找到结点`i`。因为结点i为标志位，所以去除其标志位。同时结点`i`是叶子结点，将其删除。删除后结点`h`变为叶子结点，并且结点`h`不是标志位，也将其删除。

2. 删除前缀字符串。例如删除`cod`，首先查找到末尾字符结点`d`，因为结点`d`不是叶子结点，只需将其标志位去除即可。

3. 删除分支字符串。例如删除`cook`，方法与删除整个字符串类似，区别在于当删除到共享结点`o`时，由于`o`不是叶子结点，停止删除。

<div style="page-break-after: always;"></div>

## 5.5 B树

**B树**

<img src="./img/C5/5-5/1.png" style="zoom:80%;" />

<img src="./img/C5/5-5/2.png" style="zoom:80%;" />

<img src="./img/C5/5-5/3.png" style="zoom:80%;" />

<img src="./img/C5/5-5/4.png" style="zoom:80%;" />

<img src="./img/C5/5-5/5.png" style="zoom:80%;" />

<img src="./img/C5/5-5/6.png" style="zoom:80%;" />

<img src="./img/C5/5-5/7.png" style="zoom:80%;" />

<img src="./img/C5/5-5/8.png" style="zoom:80%;" />

<img src="./img/C5/5-5/9.png" style="zoom:80%;" />

<img src="./img/C5/5-5/10.png" style="zoom:80%;" />

<img src="./img/C5/5-5/11.png" style="zoom:80%;" />

<img src="./img/C5/5-5/12.png" style="zoom:80%;" />

<img src="./img/C5/5-5/13.png" style="zoom:80%;" />

<img src="./img/C5/5-5/14.png" style="zoom:80%;" />

<img src="./img/C5/5-5/15.png" style="zoom:80%;" />

<img src="./img/C5/5-5/16.png" style="zoom: 50%;" />

<img src="./img/C5/5-5/17.png" style="zoom: 50%;" />

<img src="./img/C5/5-5/18.png" style="zoom:80%;" />

<img src="./img/C5/5-5/19.png" style="zoom: 60%;" />

<img src="./img/C5/5-5/20.png" style="zoom: 60%;" />

<img src="./img/C5/5-5/21.png" style="zoom: 60%;" />

<img src="./img/C5/5-5/22.png" style="zoom: 60%;" />

<img src="./img/C5/5-5/23.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/24.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/25.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/26.png" style="zoom: 80%;" />

一个$m $阶的`B树`具有以下特征：

1. 根结点至少有$ 2 $个孩子。
2. 每个中间结点都包含$ k-1 $个元素和$ k $个孩子（$ {m \over 2} \le k \le m $）。
3. 每个叶子结点都包含$ k - 1 $个元素（$ {m \over 2} \le k \le m $）。
4. 所有叶子结点都位于同一层。
5. 每个结点中的元素从小到大排列，结点中$ k - 1 $个元素正好是k个孩子包含的元素的值域分划。

<img src="./img/C5/5-5/27.png" style="zoom: 80%;" />

![](./img/C5/5-5/28.png)

<img src="./img/C5/5-5/29.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/30.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/31.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/32.png" style="zoom:60%;" />

<img src="./img/C5/5-5/33.png" style="zoom:60%;" />

<img src="./img/C5/5-5/34.png" style="zoom:60%;" />

<img src="./img/C5/5-5/35.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/36.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/37.png" style="zoom: 80%;" />



**插入**

<img src="./img/C5/5-5/38.png" style="zoom: 67%;" />

由于结点$ (3, 5) $已经是两元素结点，无法再增加。父结点$ (2, 6) $也是两元素结点，也无法再增加。根结点$ 9 $是单元素结点，可以升级为两元素结点。于是拆分结点$ (3, 5) $和结点$ (2, 6) $，让根结点$ 9 $升级为$ (4, 9) $，结点$ 6 $独立为根结点的第二个孩子。

<img src="./img/C5/5-5/39.png" style="zoom: 67%;" />

<img src="./img/C5/5-5/40.png" style="zoom: 80%;" />

<img src="./img/C5/5-5/41.png" style="zoom: 80%;" />



**删除**

<img src="./img/C5/5-5/42.png" style="zoom: 67%;" />

删除结点$ 11 $后，结点$ 12 $只有一个孩子，不符合`B树`特征。因此找出$ 12 $、$ 13 $、$ 15 $中的中位数$ 13 $，取代结点$ 12 $，而结点$ 12 $下移成为第一个孩子。

<img src="./img/C5/5-5/43.png" style="zoom: 67%;" />

<img src="./img/C5/5-5/44.png" style="zoom: 67%;" />

<div style="page-break-after: always;"></div>

## 5.6 B+树

**B+树**

<img src="./img/C5/5-6/1.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/2.png" style="zoom: 80%;" />

一个$ m $阶的`B+树`具有以下特征：

1. 有$ k $个子树的中间结点包含$ k $个元素（`B树`中是$ k - 1 $个元素）。
2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身按照关键字大小连接。
3. 所有中间结点元素都同时存在于子结点，在子结点元素中是最大（或最小）元素。

![](./img/C5/5-6/3.png)

<img src="./img/C5/5-6/4.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/5.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/6.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/7.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/8.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/9.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/10.png" style="zoom: 80%;" />

![](./img/C5/5-6/11.png)

<img src="./img/C5/5-6/12.png" style="zoom: 80%;" />

![](./img/C5/5-6/13.png)

<img src="./img/C5/5-6/14.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/15.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/16.png" style="zoom:67%;" />

<img src="./img/C5/5-6/17.png" style="zoom:67%;" />

<img src="./img/C5/5-6/18.png" style="zoom:67%;" />

<img src="./img/C5/5-6/19.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/20.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/21.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/22.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/23.png" style="zoom: 80%;" />



**范围查找**

<img src="./img/C5/5-6/24.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/25.png" style="zoom:67%;" />

<img src="./img/C5/5-6/26.png" style="zoom:67%;" />

<img src="./img/C5/5-6/27.png" style="zoom:67%;" />

<img src="./img/C5/5-6/28.png" style="zoom:67%;" />

<img src="./img/C5/5-6/29.png" style="zoom:67%;" />

<img src="./img/C5/5-6/30.png" style="zoom: 80%;" />

<img src="./img/C5/5-6/31.png" style="zoom:67%;" />

<img src="./img/C5/5-6/32.png" style="zoom:67%;" />

<img src="./img/C5/5-6/33.png" style="zoom:67%;" />

<img src="./img/C5/5-6/34.png" style="zoom: 80%;" />

<div style="page-break-after: always;"></div>

## 5.7 并查集

**并查集（Disjoint Set）**

并查集是一种简洁优雅的数据结构，主要用于解决一些元素分组的问题。

它管理一系列不相交的集合，并支持两种操作：

1. 合并（union）：把两个不相交的集合合并为一个集合。
2. 查询（find）：查询两个元素是否在同一个集合中。

例如在某个家族中，如果$ x $和$ y $是亲戚，$ y $和$ z $是亲戚，那么$ x $和$ z $也是亲戚。如果$ x $和$ y $是亲戚，那么$ x $的亲戚都是$ y $的亲戚，$ y $的亲戚也都是$ x $的亲戚。为了判断两个人是否为亲戚，只需判断他们是否属于同一个集合即可。

并查集的思想在于用集合中的一个元素代表集合，类似于把集合看做帮派，代表元素则是帮主，最开始所有元素各自为一个集合（各自的帮主就是自己）。

<img src="./img/C5/5-7/1.png" style="zoom: 67%;" />

例如将元素$ 1 $和$ 3 $合并，就是将$ 1 $号和$ 3 $号比武，假设$ 1 $号赢了，$ 3 $号就认$ 1 $号作帮主。

<img src="./img/C5/5-7/2.png" style="zoom: 67%;" />

再合并元素$ 2 $和$ 3 $，但$ 3 $号表示“别跟我打，让我的帮主来收拾你”。假设还是$ 1 $号赢了，$ 2 $号也认$ 1 $号作帮主。

<img src="./img/C5/5-7/3.png" style="zoom: 67%;" />

假设元素$ 4 $、$ 5 $、$ 6 $也进行了相关合并：

<img src="./img/C5/5-7/4.png" style="zoom: 67%;" />

现在再合并元素$ 2 $和$ 6 $，将它们的帮主$ 1 $号和$ 4 $号比武，假设$ 1 $号胜利后，$ 4 $号认$ 1 $号为帮主，当然它的手下也都跟着投降了。

<img src="./img/C5/5-7/5.png" style="zoom: 67%;" />

并查集是一种树型结构，要寻找集合的代表元素，只需要一层一层向上访问父结点，直达树的根结点即可。根结点的父结点就是它自己。

<img src="./img/C5/5-7/6.png" style="zoom: 60%;" />

假设有$ n $个元素，利用数组`parent`存放每个元素的父结点。一开始每个元素的父结点为自己。

---

【代码】初始化

```c
void init(int n) {
    parent = (int *)malloc(sizeof(int) * n);
    for(int i = 0; i < n; i++) {
        parent[i] = i;
    }
}
```

---

要判断两个元素是否属于同一个集合，只需要看它们的根结点是否相同。利用递归的方法可以实现对代表元素的查询，一层一层访问父结点，直至根结点。

---

【代码】查询

```c
int find(int val) {
    if(parent[val] == val) {
        return val;
    }
    return find(parent[val]);
}
```

---

合并操作需要先找到两个集合的根结点，将前者的父结点设置为后者即可（也可将后者的父结点设置为前者）。

---

【代码】合并

```c
void merge(int i, int j) {
    parent[find(i)] = find(j);
}
```

---



**路径压缩（Path Compression）**

最简单的并查集效率是比较低的，例如：

<img src="./img/C5/5-7/7.png" style="zoom: 60%;" />

分别`merge(2, 3)`和`merge(2, 4)`：

<img src="./img/C5/5-7/8.png" style="zoom: 60%;" />

这样可能会形成一条长链，随着链越来越长，想要从底部找到根结点会变得越来越难。利用路径压缩的方法可以解决这个问题，因为我们只关心一个元素所对应的根结点，因此每个元素到根结点的路径最好尽可能短。

<img src="./img/C5/5-7/9.png" style="zoom: 60%;" />

实现的时候只需在查询过程中，把沿途的每个结点的父结点都设置为根结点即可。在下一次查询的时候，就可以节省很多时间。

---

【代码】查询（路径压缩）

```c
int find(int val) {
    if(parent[val] == val) {
        return val;
    } else {
        parent[val] = find(parent[val]);
        return parent[val];
    }
}
```

---



**按秩合并**

如果需要将一棵比较复杂的树与一个单元素进行合并，例如`merge(7, 8)`时，是把元素$ 7 $的父结点设为$ 8 $好，还是把$ 8 $的父结点设为$ 7 $呢？

<img src="./img/C5/5-7/10.png" style="zoom: 60%;" />

如果把$ 7 $的父结点设为$ 8 $，会使树的深度加深，原来树中的每个元素到根结点的距离都变长了，之后寻找根结点的路径也会变长。虽然有路径压缩，但路径压缩也是要消耗时间的。而把$ 8 $的父结点设为$ 7 $，并不会影响到不相关的结点。

<img src="./img/C5/5-7/11.png" style="zoom: 60%;" />

因此在合并两个集合时，应该把简单的树往复杂的树上合并。利用数组`rank`记录每个结点对应的树的深度，一开始所有元素的`rank`设为$ 1 $。合并时比较两个根结点，把`rank`较小者往较大者上合并。

---

【代码】按秩合并

```c
void init(int n) {
    parent = (int *)malloc(sizeof(int) * n);
    rank = (int *)malloc(sizeof(int) * n);
    for(int i = 0; i < n; i++) {
        parent[i] = i;
        rank[i] = 1;
    }
}

void merge(int i, int j) {
    // 找到对应根结点
    int x = find(i);
    int y = find(j);
    if(rank[x] <= rank[y]) {
        parent[x] = y;
    } else {
        parent[y] = x;
    }
    // 如果深度相同且根结点不同，则新的根结点深度+1
    if(rank[x] == rank[y] && x != y) {
        rank[y]++;
    }
}
```

---

深度相同的情况下，无论如何合并，都会使树的深度增加$ 1 $。

<img src="./img/C5/5-7/12.png" style="zoom: 50%;" />

<img src="./img/C5/5-7/13.png" style="zoom: 50%;" />