\chapter{图}

\section{图}

\subsection{图（Graph）}

你的微信中有若干好友，而你的好友又有若干好友。许许多多的用户组成了一个多对多的关系网，这个关系网就是数据结构中的图。 \\

再例如使用地图导航功能时，导航会根据你的出发地和目的地规划最佳的地铁换乘路线。许许多多的地铁站组成的交通网络也可以认为是图。 \\

图是一种比树更为复杂的数据结构。树的结点之间是一对多的关系，并且存在父与子的层级划分。而图的顶点之间是多对多关系，并且所有顶点都是平等的，无所谓谁是父子。 \\

在图中，最基本的单元是顶点（vertex），相当于树中的结点。顶点之间的关联关系被称为边（edge）。图中包含一组顶点和一组边，通常用V表示顶点集合，用E表示边集合。边可以看作是顶点对，即$ (v, w) \in E,\ v, w \in V $。 \\

在有些图中，每一条边并不是完全等同的。例如地铁线路，站与站之间的距离都有可能不同。因此图中会涉及边的权重（weight），涉及到权重的图被称为带权图（weighted graph），也称为网络。

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (A) at (0,0) {A};
            \node (B) at (0,3) {B};
            \node (C) at (2.5,4) {C};
            \node (D) at (2.5,1) {D};
            \node (E) at (2.5,-3) {E};
            \node (F) at (5,3) {F};
        \end{scope}

        \begin{scope}[>={Stealth[black]},
            every node/.style={fill=white,circle},
            every edge/.style={draw=black,very thick}]
            \path [-] (A) edge node {5} (B);
            \path [-] (B) edge node {3} (C);
            \path [-] (A) edge node {4} (D);
            \path [-] (D) edge node {3} (C);
            \path [-] (A) edge node {3} (E);
            \path [-] (D) edge node {3} (E);
            \path [-] (D) edge node {3} (F);
            \path [-] (C) edge node {5} (F);
            \path [-] (E) edge node {8} (F);
        \end{scope}
    \end{tikzpicture}
    \caption{带权图}
\end{figure}

还有一种图，顶点之间的关联并不是完全对称的。拿微信举例，你的好友列表里有我，但我的好友列表里未必有你。 \\

这样一来，顶点之间的边就有了方向的区分，这种带有方向的图被称为有向图（directed graph）。有向边可以使用<v, w>表示从v指向w的边。 \\

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (A) at (0,0) {A};
            \node (B) at (0,3) {B};
            \node (C) at (2.5,4) {C};
            \node (D) at (2.5,1) {D};
            \node (E) at (5,0) {E};
        \end{scope}

        \begin{scope}[>={Stealth[black]},
            every node/.style={fill=white,circle},
            every edge/.style={draw=black,very thick}]
            \path [<->] (A) edge node {5} (B);
            \path [->] (B) edge node {3} (C);
            \path [->] (A) edge node {4} (D);
            \path [<->] (D) edge node {3} (C);
            \path [<->] (A) edge node {3} (E);
            \path [->] (D) edge node {3} (E);
        \end{scope}
    \end{tikzpicture}
    \caption{有向图}
\end{figure}

相应地，在QQ中，只要我把你从好友里删除，你在自己的好友列表里就看不到我了。因此QQ的好友关系可以认为是一个没有方向区分的图，这种图被称为无向图（undirected graph）。

\newpage

\section{图的表示}

\subsection{邻接矩阵（Adjacency Matrix）}

拥有n个顶点的图，它所包含的边的数量最多是n(n-1)条，因此，要表达各个顶点之间的关联关系，最清晰易懂的方式是使用邻接矩阵G[N][N]。 \\

对于无向图来说，如果顶点之间有关联，那么邻接矩阵中对应的值为1；如果顶点之间没有关联，那么邻接矩阵中对应的值为0。

\begin{align}\nonumber
    G[i][j] = \begin{cases}
        1 & <v_i, v_j>\text{是G中的边}   \\
        0 & <v_i, v_j>\text{不是G中的边} \\
    \end{cases}
\end{align}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (A) at (0,0) {A};
            \node (B) at (0,3) {B};
            \node (C) at (2.5,4) {C};
            \node (D) at (2.5,1) {D};
            \node (E) at (4,2) {E};
        \end{scope}

        \begin{scope}[>={Stealth[black]},
            every node/.style={},
            every edge/.style={draw=black,very thick}]
            \path [-] (A) edge node {} (B);
            \path [-] (A) edge node {} (D);
            \path [-] (B) edge node {} (C);
            \path [-] (C) edge node {} (D);
            \path [-] (C) edge node {} (E);
        \end{scope}
    \end{tikzpicture}
\end{figure}

\begin{table}[H]
    \centering
    \setlength{\tabcolsep}{5mm}{
        \begin{tabular}{|c|c|c|c|c|c|}
            \hline
                       & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} \\
            \hline
            \textbf{A} & 0          & 1          & 0          & 1          & 0          \\
            \hline
            \textbf{B} & 1          & 0          & 1          & 0          & 0          \\
            \hline
            \textbf{C} & 0          & 1          & 0          & 1          & 1          \\
            \hline
            \textbf{D} & 1          & 0          & 1          & 0          & 0          \\
            \hline
            \textbf{E} & 0          & 0          & 1          & 0          & 0          \\
            \hline
        \end{tabular}
    }
    \caption{无向图邻接矩阵}
\end{table}

需要注意的是，邻接矩阵从左上到右下的一条对角线上的元素值必然是0，因为任何一个顶点与它自身是没有连接的。同时，无向图对应的邻接矩阵是一个对称矩阵，假如A和B有关联，那么B和A也必定有关联。 \\

但是对于有向图的邻接矩阵，不一定是一个对称矩阵，假如A可以达到B，从B未必能达到A。 \\

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (A) at (0,0) {A};
            \node (B) at (0,3) {B};
            \node (C) at (2.5,4) {C};
            \node (D) at (2.5,1) {D};
        \end{scope}

        \begin{scope}[>={Stealth[black]},
            every node/.style={},
            every edge/.style={draw=black,very thick}]
            \path [->] (A) edge node {} (B);
            \path [->] (A) edge node {} (C);
            \path [<->] (C) edge node {} (D);
            \path [->] (D) edge node {} (B);
        \end{scope}
    \end{tikzpicture}
\end{figure}

\begin{table}[H]
    \centering
    \setlength{\tabcolsep}{5mm}{
        \begin{tabular}{|c|c|c|c|c|}
            \hline
                       & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} \\
            \hline
            \textbf{A} & 0          & 1          & 1          & 0          \\
            \hline
            \textbf{B} & 0          & 0          & 0          & 0          \\
            \hline
            \textbf{C} & 0          & 0          & 0          & 1          \\
            \hline
            \textbf{D} & 0          & 1          & 1          & 0          \\
            \hline
        \end{tabular}
    }
    \caption{有向图邻接矩阵}
\end{table}

对于网络，只要把邻接矩阵对应位置的值定义为边$ <v_i, v_j> $的权重即可。 \\

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (A) at (0,0) {A};
            \node (B) at (3,0) {B};
            \node (C) at (5,2.5) {C};
            \node (D) at (1.5,5) {D};
            \node (E) at (-2,2.5) {E};
            \node (F) at (1.5,2.5) {F};
        \end{scope}

        \begin{scope}[>={Stealth[black]},
            every node/.style={fill=white,circle},
            every edge/.style={draw=black,very thick}]
            \path [->] (A) edge node {5} (B);
            \path [->] (A) edge node {2} (F);
            \path [->] (B) edge node {4} (C);
            \path [->] (C) edge node {9} (D);
            \path [->] (D) edge node {7} (E);
            \path [->] (D) edge node {3} (F);
            \path [->] (E) edge node {1} (A);
            \path [->] (F) edge node {1} (C);
            \path [->] (F) edge node {8} (E);
        \end{scope}
    \end{tikzpicture}
\end{figure}

\begin{table}[H]
    \centering
    \setlength{\tabcolsep}{5mm}{
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
                       & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} \\
            \hline
            \textbf{A} & $ \infty $ & 5          & $ \infty $ & $ \infty $ & $ \infty $ & 2          \\
            \hline
            \textbf{B} & $ \infty $ & $ \infty $ & 4          & $ \infty $ & $ \infty $ & $ \infty $ \\
            \hline
            \textbf{C} & $ \infty $ & $ \infty $ & $ \infty $ & 9          & $ \infty $ & $ \infty $ \\
            \hline
            \textbf{D} & $ \infty $ & $ \infty $ & $ \infty $ & $ \infty $ & 7          & 3          \\
            \hline
            \textbf{E} & 1          & $ \infty $ & $ \infty $ & $ \infty $ & $ \infty $ & $ \infty $ \\
            \hline
            \textbf{F} & $ \infty $ & $ \infty $ & 1          & $ \infty $ & 8          & $ \infty $ \\
            \hline
        \end{tabular}
    }
    \caption{带权图邻接矩阵}
\end{table}

对于带权图，如果$ v_i $和$ v_j $之前没有边应该将权值设为$ \infty $。 \\

邻接矩阵的优点：

\begin{enumerate}
    \item 简单、直观。
    \item 可以快速查到一个顶点和另一顶点之间的关联关系。
    \item 方便计算任一顶点的度，对于有向图，从顶点发出的边数为出度，指向顶点的边数为入度。
\end{enumerate}

邻接矩阵的缺点：

\begin{enumerate}
    \item 浪费空间，对于稀疏图（点很多而边很少）有大量无效元素。但对于稠密图（特别是完全图）还是很合算的。
    \item 浪费时间，统计稀疏图中边的个数，也就是计算邻接矩阵中元素1的个数。
\end{enumerate}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \draw[thick,black]  (18:2) \foreach \a in {90,162,234,306} { -- (\a:2) } -- cycle;
        \draw[thick,black] (18:2) \foreach \a in {162,306,90,234} { -- (\a:2) } -- cycle;
        \foreach \a in {18,90,162,234,306} { \node[black,fill=black,circle,inner sep=2pt] at (\a:2){}; }
    \end{tikzpicture}
    \caption{完全图}
\end{figure}

\subsection{邻接表（Adjacency List）}

为了解决邻接矩阵占用空间的问题，人们想到了另一种图的表示方法——邻接表。在邻接表中，图的每一个顶点都是一个链表的头结点，其后连接着该顶点能够直接到达的相邻顶点。对于稀疏图而言，邻接表存储方式占用的空间比邻接矩阵要小得多。 \\

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (A) at (0,0) {A};
            \node (B) at (0,3) {B};
            \node (C) at (2.5,4) {C};
            \node (D) at (2.5,1) {D};
        \end{scope}

        \begin{scope}[>={Stealth[black]},
            every node/.style={},
            every edge/.style={draw=black,very thick}]
            \path [->] (A) edge node {} (B);
            \path [->] (A) edge node {} (C);
            \path [<->] (C) edge node {} (D);
            \path [->] (D) edge node {} (A);
        \end{scope}
    \end{tikzpicture}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \coordinate (0);
        \foreach \t[count=\i from 0,evaluate=\i as\j using int(\i+1)] in {
                1 $ \rightarrow $ 2,
                ,
                3,
                1 $ \rightarrow $ 2
            }
        \node at(\i.south)[anchor=north,draw,minimum height=2em,minimum width=1.5em,outer sep=0pt](\j){}
        node at(\j.west)[align=right,left]{\i}
        node at(\j.east)[align=left,right,xshift=-.7em]{$ \rightarrow $ \t};
    \end{tikzpicture}
    \caption{邻接表}
\end{figure}

通过遍历邻接表可以查找到所有能够到达的相邻顶点，但是对于逆向查找，即哪些顶点可以达到一个顶点就会很麻烦。 \\

逆邻接表和邻接表是正好相反的，逆邻接表每一个顶点作为链表的头结点，后继结点所存储的是能够直接到达该顶点的相邻顶点。

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \coordinate (0);
        \foreach \t[count=\i from 0,evaluate=\i as\j using int(\i+1)] in {
                ,
                0 $ \rightarrow $ 3,
                0 $ \rightarrow $ 3,
                2
            }
        \node at(\i.south)[anchor=north,draw,minimum height=2em,minimum width=1.5em,outer sep=0pt](\j){}
        node at(\j.west)[align=right,left]{\i}
        node at(\j.east)[align=left,right,xshift=-.7em]{$ \rightarrow $ \t};
    \end{tikzpicture}
    \caption{逆邻接表}
\end{figure}

可是，一个图要维护正反两个邻接表，也太麻烦了吧？ \\

通过十字链表可以把邻接表和逆邻接表结合在一起。 \\

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \coordinate (0);
        \foreach \t[count=\i from 0,evaluate=\i as\j using int(\i+1)] in {
                1 $ \rightarrow $ 2,
                ,
                3,
                1 $ \rightarrow $ 2
            }
        \node at(\i.south)[anchor=north,draw,minimum height=2em,minimum width=1.5em,outer sep=0pt](\j){}
        node at(\j.east)[align=right,left]{\i}
        node at(\j.east)[align=left,right,xshift=-.7em]{$ \rightarrow $ \t};

        \draw (-0.4,-0.5) node{$ \leftarrow $};
        \draw (-1,-1.2) node{$ 3 \leftarrow 0 \leftarrow $};
        \draw (-1,-2) node{$ 3 \leftarrow 0 \leftarrow $};
        \draw (-0.5,-2.9) node{$ 2 \leftarrow $};
    \end{tikzpicture}
    \caption{十字链表}
\end{figure}

\newpage

\section{图的遍历}

\subsection{深度优先搜索（DFS, Depth First Search）}

深度优先搜索是一种一头扎到底的遍历方法，选择一条支路，尽可能不断地深入，如果遇到死路就回退，回退过程中如果遇到没探索的支路，就进入该支路继续深入。 \\

例如有一个小镇，你知道小镇的每个地方与每条路。小镇的每个地方都藏有可以实现愿望的光玉，现在你要出发去收集小镇上所有的光玉。你的出生点在0号位置，你需要一个地点都不遗漏地走完整个小镇，才能收集完所有光玉。 \\

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (2.5,4) {0};
            \node (1) at (5,3) {1};
            \node (2) at (2.5,2) {2};
            \node (3) at (1,0) {3};
            \node (4) at (3,0) {4};
            \node (5) at (5,1) {5};
            \node (6) at (6,-1) {6};
            \node (7) at (0,3) {7};
        \end{scope}

        \begin{scope}[>={Stealth[black]},
            every node/.style={},
            every edge/.style={draw=black,very thick}]
            \path [-] (0) edge node {} (1);
            \path [-] (0) edge node {} (2);
            \path [-] (0) edge node {} (7);
            \path [-] (1) edge node {} (4);
            \path [-] (1) edge node {} (5);
            \path [-] (2) edge node {} (4);
            \path [-] (3) edge node {} (4);
            \path [-] (5) edge node {} (6);
        \end{scope}
    \end{tikzpicture}
\end{figure}

二叉树的先序遍历本质上也可以认为是图的深度优先遍历。要想实现回溯，可以利用栈的先进后出的特性，也可以采用递归的方式，因为递归本身就是基于方法调用栈来实现的。

\begin{algorithm}[H]
    \caption{深度优先搜索}
    \begin{algorithmic}[1]
        \Procedure{dfs}{Vertex V}
        \State isVisited[V] = true
        \For {v in V}
        \If {!isVisited[v]}
        dfs(v)
        \EndIf
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{广度优先搜索（BFS, Breath First Search）}

除了深度优先搜索一头扎到底的方法以外，还有一种方法就是首先把从源点相邻的顶点遍历，然后再遍历稍微远一点的顶点，再去遍历更远一点的顶点。 \\

二叉树的层次遍历本质上也可以认为是图的广度优先遍历，需要借助队列来实现重放。 \\

