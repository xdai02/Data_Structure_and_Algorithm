<center><h1>数据结构</h1></center>

<div style="border-bottom: none;"><center><h3>目录</h3></center></div>

[TOC]

<div style="page-break-after: always;"></div>

# 第8章 图

## 8.1 图

**图（Graph）**

例如，你的微信中有若干好友，而你的好友又有若干好友。

<img src="./img/C8/8-1/1.png" style="zoom: 50%;" />

许许多多的用户组成了一个多对多的关系网，这个关系网就是数据结构中的图。

再例如使用地图导航功能时，导航会根据你的出发地和目的地规划最佳的地铁换乘路线。许许多多的地铁站组成的交通网络也可以认为是图。

<img src="./img/C8/8-1/2.png" style="zoom: 50%;" />

图是一种比树更为复杂的数据结构。树的结点之间是一对多的关系，并且存在父与子的层级划分。而图的顶点之间是多对多关系，并且所有顶点都是平等的，无所谓谁是父子。

在图中，最基本的单元是顶点（vertex），相当于树中的结点。顶点之间的关联关系被称为边（edge）。图中包含一组顶点和一组边，通常用$ V $表示顶点集合，用$ E $表示边集合。边可以看作是顶点对，即$ (v, w) \in E,\ v, w \in V $。

在有些图中，每一条边并不是完全等同的。例如地铁线路，站与站之间的距离都有可能不同。因此图中会涉及边的权重（weight），涉及到权重的图被称为带权图（weighted graph），也称为网络。

<img src="./img/C8/8-1/3.png" style="zoom:67%;" />

还有一种图，顶点之间的关联并不是完全对称的。拿微信举例，你的好友列表里有我，但我的好友列表里未必有你。

<img src="./img/C8/8-1/4.png" style="zoom: 67%;" />

<img src="./img/C8/8-1/5.png" style="zoom:67%;" />

<img src="./img/C8/8-1/6.png"  />

<img src="./img/C8/8-1/7.png" style="zoom:67%;" />

这样一来，顶点之间的边就有了方向的区分，这种带有方向的图被称为有向图（directed graph）。有向边可以使用$ <v, w> $表示从$ v $指向$ w $的边。

<img src="./img/C8/8-1/8.png" style="zoom: 50%;" />

相应地，在QQ中，只要我把你从好友里删除，你在自己的好友列表里就看不到我了。因此QQ的好友关系可以认为是一个没有方向区分的图，这种图被称为无向图（undirected graph）。

<div style="page-break-after: always;"></div>

## 8.2 图的表示

**邻接矩阵（Adjacency Matrix）**

拥有$ n $个顶点的图，它所包含的边的数量最多是$ n(n-1) $条，因此，要表达各个顶点之间的关联关系，最清晰易懂的方式是使用邻接矩阵$ G[N][N] $。

对于无向图来说，如果顶点之间有关联，那么邻接矩阵中对应的值为`1`；如果顶点之间没有关联，那么邻接矩阵中对应的值为`0`。
$$
G[i][j] = \left\{
\begin{aligned}
& 1 & <v_i, v_j>\text{是}G\text{中的边} \\
& 0 & <v_i, v_j>\text{不是}G\text{中的边} \\
\end{aligned}
\right.
$$

```mermaid
graph LR
	V0((V0))
	V1((V1))
	V2((V2))
	V3((V3))
	V4((V4))
	
	V0 --- V1
	V0 --- V3
	V1 --- V2
	V2 --- V3
	V2 --- V4
```

|   G    |  V0  |  V1  |  V2  |  V3  |  V4  |
| :----: | :--: | :--: | :--: | :--: | :--: |
| **V0** |  0   |  1   |  0   |  1   |  0   |
| **V1** |  1   |  0   |  1   |  0   |  0   |
| **V2** |  0   |  1   |  0   |  1   |  1   |
| **V3** |  1   |  0   |  1   |  0   |  0   |
| **V4** |  0   |  0   |  1   |  0   |  0   |

需要注意的是，邻接矩阵从左上到右下的一条对角线上的元素值必然是0，因为任何一个顶点与它自身是没有连接的。同时，无向图对应的邻接矩阵是一个对称矩阵，假如V1和V2有关联，那么V2和V1也必定有关联。

但是对于有向图的邻接矩阵，不一定是一个对称矩阵，假如V1可以达到V2，从V2未必能达到V1。

```mermaid
graph LR
	V0((V0))
	V1((V1))
	V2((V2))
	V3((V3))
	
	V0 --> V1
	V0 --> V2
	V2 --> V3
	V3 --> V1
	V3 --> V2
```

|   G    |  V0  |  V1  |  V2  |  V3  |
| :----: | :--: | :--: | :--: | :--: |
| **V0** |  0   |  1   |  1   |  0   |
| **V1** |  0   |  0   |  0   |  0   |
| **V2** |  0   |  0   |  0   |  1   |
| **V3** |  0   |  1   |  1   |  0   |

对于网络，只要把邻接矩阵对应位置的值定义为边$ <v_i, v_j> $的权重即可。

<img src="./img/C8/8-2/1.png" style="zoom:80%;" />

|   G    |  V0  |  V1  |  V2  |  V3  |  V4  | V5 |
| :----: | :--: | :--: | :--: | :--: | :--: | :--: |
| **V0** |     |  5  |     |     |     |  2  |
| **V1** |     |     |  4  |     |     |     |
| **V2** |     |     |     |  9  |     |     |
| **V3** |     |     |     |     |  7  |  3  |
| **V4** |  1  |     |     |     |     |     |
| **V5** |     |     |  1  |     |  8  |     |

但如果$ v_i $和$ v_j $之前没有边该怎么表示？还是设为0吗？

<img src="./img/C8/8-2/2.png" style="zoom:50%;" />

邻接矩阵的优点：

1. 简单、直观。
2. 可以快速查到一个顶点和另一顶点之间的关联关系。
3. 方便计算任一顶点的度，对于有向图，从顶点发出的边数为`出度`，指向顶点的边数为`入度`。

邻接矩阵的缺点：

1. 浪费空间，对于稀疏图（点很多而边很少）有大量无效元素。但对于稠密图（特别是完全图）还是很合算的。
2. 浪费时间，统计稀疏图中边的个数，也就是计算邻接矩阵中元素`1`的个数。

<img src="./img/C8/8-2/3.png" style="zoom:50%;" />



**邻接表（Adjacency List）**

为了解决邻接矩阵占用空间的问题，人们想到了另一种图的表示方法——邻接表。在邻接表中，图的每一个顶点都是一个链表的头结点，其后连接着该顶点能够直接到达的相邻顶点。对于稀疏图而言，邻接表存储方式占用的空间比邻接矩阵要小得多。

<img src="./img/C8/8-2/4.png" style="zoom:80%;" />

通过遍历邻接表可以查找到所有能够到达的相邻顶点，但是对于逆向查找，即哪些顶点可以达到一个顶点就会很麻烦。

通过逆邻接表可以解决逆向查找的麻烦。逆邻接表和邻接表是正好相反的，逆邻接表每一个顶点作为链表的头结点，后继结点所存储的是能够直接到达该顶点的相邻顶点。

<img src="./img/C8/8-2/5.png" style="zoom:80%;" />

<img src="./img/C8/8-2/6.png" style="zoom:67%;" />

<img src="./img/C8/8-2/7.png" style="zoom:67%;" />

<img src="./img/C8/8-2/8.png" style="zoom:80%;" />

<div style="page-break-after: always;"></div>

## 8.3 图的遍历

**深度优先搜索（DFS, Depth First Search）**

深度优先搜索是一种一头扎到底的遍历方法，选择一条支路，尽可能不断地深入，如果遇到死路就回退，回退过程中如果遇到没探索的支路，就进入该支路继续深入。

例如有一个小镇，你知道小镇的每个地方与每条路。小镇的每个地方都藏有可以实现愿望的光玉，现在你要出发去收集小镇上所有的光玉。你的出生点在0号位置，你需要一个地点都不遗漏地走完整个小镇，才能收集完所有光玉。

<img src="./img/C8/8-3/1.png" style="zoom: 67%;" />

二叉树的先序遍历本质上也可以认为是图的深度优先遍历。要想实现回溯，可以利用栈的先进后出的特性，也可以采用递归的方式，因为递归本身就是基于方法调用栈来实现的。

---

【代码】深度优先搜索

```
dfs(Vertex V):
    isVisited[V] = true
    for(v in V)
        if(!isVisited[v])
            dfs(v)
```

---



**广度优先搜索（BFS, Breath First Search）**

除了深度优先搜索一头扎到底的方法以外，还有一种方法就是首先把从源点相邻的顶点遍历，然后再遍历稍微远一点的顶点，再去遍历更远一点的顶点。

二叉树的层次遍历本质上也可以认为是图的广度优先遍历，需要借助队列来实现重放。

<img src="./img/C8/8-3/2.png" style="zoom:80%;" />

---

【代码】广度优先搜索

```
bfs(Vertex V):
    isVisited[V] = true
    enqueue(Q, V)
    while(!isEmpty(Q))
        V = dequeue(Q)
        for(v in V)
            if(!isVisited[v])
                isVisited[v = true
                enqueue(Q, v)
```

---

<div style="page-break-after: always;"></div>

## 8.4 连通图

**连通图**

图还有一些有关路径的术语：

- 连通：如果从顶点$ V $到$ W $存在一条路径，则称$ V $和$ W $是连通的。
- 路径：顶点$ V $到$ W $的路径是一系列顶点$ \{V, v_1, v_2, \dots, v_n, W\} $的集合，其中任意一对相邻的顶点间都有图中的边。
- 路径长度：路径中边的个数，如果是带权图（网络），则是所有边的权重和。
- 简单路径：顶点$ V $到$ W $之间的路径中所有顶点都不同。
- 回路：起点等于终点的路径。

如果图中任意两顶点均连通，那么称这个图是一个连通图。

一个图的连通分量指的是图的极大连通子图，极大连通子图需要满足两点要求：

1. 顶点数到达极大，即再加一个顶点就不连通了。
2. 边数达到极大，即包含子图中所有顶点相连的所有边。

<img src="./img/C8/8-4/1.png" style="zoom:90%;" />

对于有向图而言，如果有向图中任意一对顶点$ V $和$ W $之间存在双向路径，既可以从$ V $走到$ W $，也可以从$ W $走到$ V $，但这两条路径不一定是同一条，则称该图为强连通图。

如果有向图不是强连通图，但将所有的有向边替换为无向边之后可以变为连通图，则称该图为弱连通图。

有向图的极大强连通子图称为强连通分量。

<img src="./img/C8/8-4/2.png" style="zoom:90%;" />



**非连通图的遍历**

如果一个图不是连通图，那么无论使用深度优先遍历还是广度优先遍历，都会有顶点无法被访问到。解决这个问题的方式是每调用一次`dfs(V)`或`bfs(V)`，就把顶点$ V $所在的连通分量遍历一遍。

---

【代码】非连通图的深度优先遍历

```
dfs(Vertex V):
    isVisited[V] = true
    for(v in V)
        if(!isVisited[v])
            dfs(v)

listComponents(Graph G):
    for(V in G)
        if(!isVisited[V])
            dfs(V)
```

---

<div style="page-break-after: always;"></div>

## 8.5 最短路径

**最短路径（Shortest Path）**

在现实中很多需要都运用到了最短路径的算法，例如从一个地铁站到另一个地铁站的最快换乘路线等。地铁线路图中，地铁站可以看作是图的顶点，站与站之间的线路可以看作是边，权重可以是距离、时间、费用等。

<img src="./img/C8/8-5/1.png" style="zoom: 33%;" />

在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径，这条路径就是两点之间的最短路径。其中最短路径的第一个顶点称为源点（source），最后一个顶点为终点（destination）。

图的最短路径问题分为2种类型：

1. 单源最短路径：从某固定源点出发，求到所有其它顶点的最短路径。
2. 多源最短路径：求任意两顶点间的最短路径。



**无权图的单源最短路径算法（SSSP, Single-Source Shortest Path）**

无权图的单源最短路径算法可以按照递增（非递减）的顺序找出到各个顶点的最短路，算法类似广度优先遍历。

<img src="./img/C8/8-5/2.png" style="zoom:90%;" />

---

【代码】无权图的单源最短路径

```
unweightedSSSP(Vertex S):
    enqueue(Q, S)
    while(!isEmpty(Q))
        V = dequeue(Q)
        for(v in V)
            if(dist[v] == -1)
                dist[v] = dist[V] + 1
                path[v] = V
                enqueue(Q, v)
```

---

无权图的单元最短路径算法中，`dist[v]`存储从源点$ S $到$ v $的最短路径，初始化源点`dist[S]`的距离为$ 0 $，`path[v]`表示达到顶点路径$ v $上一个经过的顶点。

|   顶点   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **dist** |  1   |  2   |  0   |  2   |  3   |  1   |  3   |
| **path** |  3   |  1   |  -1  |  1   |  2   |  3   |  4   |



**有权图的单源最短路径算法**

有权图的最短路径不一定是经过顶点树最少的路。如果图中存在负值圈（negative-cost cycle）的话会导致算法失效，因为沿着回路走无穷多次，花销是负无穷。

<img src="./img/C8/8-5/3.png" style="zoom:90%;" />

<img src="./img/C8/8-5/4.png" style="zoom:90%;" />

<img src="./img/C8/8-5/5.png" style="zoom: 60%;" />

<img src="./img/C8/8-5/6.png" style="zoom: 60%;" />

<img src="./img/C8/8-5/7.png" style="zoom: 60%;" />

<img src="./img/C8/8-5/8.png" style="zoom: 60%;" />

迪杰斯特拉（Dijkstra）算法的本质是不断刷新起点与其他各个顶点之间的距离表。`Dijkstra`算法采用了贪心的思想，每次都未收录的顶点中选取`dist`值最小的收录。每当收录一个顶点时，可能会影响另外一个顶点的`dist`值。
$$
dist[w] = min\{dist[w], dist[v] + weight_{<v, w>}\}
$$
例如计算从源点$ A $到其它各顶点的最短路径。

第1步：创建距离表。其中表中`key`是顶点名称，`value`是源点$ A $到对应顶点的已知最短距离。一开始并不知道最短路径是多少，因此`value`都为无穷大。

<img src="./img/C8/8-5/9.png" style="zoom: 67%;" />

第2步：找到源点$ A $的邻接点$ B $和$ C $，从$ A $到$ B $的距离是`5`，从$ A $到$ C $的距离是`2`。更新距离表。

<img src="./img/C8/8-5/10.png" style="zoom: 67%;" />

第3步：从距离表中找到从$ A $出发距离最短的顶点，也就是顶点$ C $。找到顶点$ C $的邻接点$ D $和$ F $（$ A $已经遍历过不需要考虑）。从$ C $到$ D $的距离是`6`，所以从$ A $到$ D $的距离是`2 + 6 = 8`；从$ C $到$ F $的距离是`8`，所以从$ A $到$ F $的距离是`2 + 8 = 10`。更新距离表。

<img src="./img/C8/8-5/11.png" style="zoom: 67%;" />

第4步：从距离表中找到从$ A $出发距离最短的顶点（$ C $已经遍历过不需要考虑），也就是顶点$ B $。找到顶点$ B $的邻接点$ D $和$ E $（$ A $已经遍历过不需要考虑）。从$ B $到$ D $的距离是`1`，所以从$A $到$ D $的距离是`5 + 1 = 6`，小于距离表中的`8`；从$ B $到$ E $的距离是`6`，所以从$ A $到$ E $的距离是`5 + 6 = 11`。更新距离表。

<img src="./img/C8/8-5/12.png" style="zoom: 67%;" />

第5步：从距离表中找到从$ A $出发距离最短的顶点（$ B $和$ C $不用考虑），也就是顶点$ D $。找到顶点$ D $的邻接点$ E $和$ F $。从$ D $到$ E $的距离是`1`，所以从$ A $到$ E $的距离是`6 + 1 = 7`，小于距离表中的`11`；从$ D $到$ F $的距离是`2`，所以从$ A $到$ F $的距离是`6 + 2 = 8`，小于距离表中的`10`。更新距离表。

<img src="./img/C8/8-5/13.png" style="zoom: 67%;" />

第6步：从距离表中找到从$ A $出发距离最短的顶点，也就是顶点$ E $。找到顶点$ E $的邻接点$ G $。从$ E $到$ G $的距离是`7`，所以从$ A $到$ G $的距离是`7 + 7 = 14`。更新距离表。

<img src="./img/C8/8-5/14.png" style="zoom: 67%;" />

第7步：从距离表中找到从$ A $出发距离最短的顶点，也就是顶点$ F $。找到顶点$ F $的邻接点$ G $。从$ F $到$ G $的距离是`3`，所以从$ A $到$ G $的距离是`8 + 3 = 11`，小于距离表中的`14`。更新距离表。

<img src="./img/C8/8-5/15.png" style="zoom: 67%;" />

最终，距离表中存储的是从源点$ A $到所有顶点的最短距离。



**多源最短路径算法**

<img src="./img/C8/8-5/16.png" style="zoom: 67%;" />

<img src="./img/C8/8-5/17.png" style="zoom: 67%;" />

<img src="./img/C8/8-5/18.png" style="zoom: 67%;" />

弗洛伊德（Floyd-Warshall）算法是专门用于寻找带权图中多源点之间的最短路径算法。`Floyd`算法的思想是，若想缩短两点间的距离，仅有一种方式，那就是通过第三顶点绕行。

假设$ D^k[i][j]$为路径$ \{i \rarr \{l \le k\} \rarr j\} $的最小长度。当$ D^{k-1} $已经完成，递推到$ D^k $时：

1. 如果$ k \notin \text{最短路径}\{i \rarr \{l \le k\} \rarr j\} $，则$ D^k = D^{k-1} $。
2. 如果$ k \in \text{最短路径}\{i \rarr \{l \le k\} \rarr j\} $，该路径必定由两段最短路径组成，则$ D^k[i][j] = D^{k-1}[i][k] + D^{k-1}[k][j] $。

例如，小哼准备去一些城市旅游，有些城市之间有公路，有些城市之间则没有。为了节省经费以及方便计划旅程，小哼希望在出发之前直到任意两个城市之间的最短路程。

<img src="./img/C8/8-5/19.png" style="zoom: 67%;" />

如果要让任意两点之间的路程变短，只能引入第三个点，并通过这个顶点中转才有可能缩短原来的路程。这个中转的顶点甚至有时候不只通过一个顶点，而是经过两个或更多点中转会更短。

当任意两点之间不允许经过第三个点中转时，这些城市之间的最短路径就是邻接矩阵的初始路径。

<img src="./img/C8/8-5/20.png"  />

在只允许经过$ 1 $号顶点中转的情况下，任意两点之间的最短路程更新为：

![](./img/C8/8-5/21.png)

在只允许经过$ 1 $号和$ 2 $号顶点中转的情况下，任意两点之间的最短路程更新为：

![](./img/C8/8-5/22.png)

在只允许经过$ 1 $号、$ 2 $号和$ 3 $号顶点中转的情况下，任意两点之间的最短路程更新为：

![](./img/C8/8-5/23.png)

最后允许通过所有顶点作为中转，任意两点之间的最短路程更新为：

![](./img/C8/8-5/24.png)

---

【代码】Floyd最短路径

```c
void floyd(Graph *g, int dist[MAX][MAX]) {
    // 最短路径矩阵初始化为图的邻接矩阵
    for(int i = 0; i < g->vertexNum; i++) {
        for(int j = 0; j < g->vertexNum; j++) {
            dist[i][j] = g->weight[i][j];
        }
    }

    // Floyd算法
    for(int k = 0; k < g->vertexNum; k++) {
        for(int i = 0; i < g->vertexNum; i++) {
            for(int j = 0; j < g->vertexNum; j++) {
                if(dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
}
```

---

<div style="page-break-after: always;"></div>

## 8.6 最小生成树

**最小生成树（MST, Mininum Spanning Tree）**

所谓最小生成树，就是一个图的极小连通子图，它包含原图的所有顶点，并且所有边的权值之和尽可能小。

最小生成树需要满足3个条件：

1. 是一棵树：树不能有回路，并且$ |V| $个顶点一定有$ |V| - 1 $条边。
2. 是生成树：包含原图的全部顶点，树的$ |V| - 1 $条边都必须在图里，并且如果向生成树中任意加一条边都一定构成回路。
3. 边的权重和最小。

如果最小生成树存在，那么图一定连通，反之亦然。

例如一个带权图，绿色边可以把所有顶点连接起来，又保证边的权值和最小。

<img src="./img/C8/8-6/1.png" style="zoom: 50%;" />

<img src="./img/C8/8-6/2.png" style="zoom: 50%;" />

图的最小生成树不是唯一的，同一个图有可能对应多个最小生成树。

最小生成树在现实中很很多用处。假如要在若干个城市之间铺设铁路，而预算又是有限的，那么就需要寻找成本最低的铺设方式。城市之间的交通网就像一个连通图，其实并不需要在每两个城市之间都直接进行连接，只需要一个最小生成树，保证所有的城市都有铁路可以达到即可。

获得最小生成树的常用算法有2个：

- `Prim`
- `Kruskal`



**Prim**

`Prim`算法是以图的顶点为基础，从一个初始顶点开始，寻找达到其它顶点权值最小的边，并把该顶点加入到已触达顶点的集合中。当全部顶点都加入到集合时，算法的工作就完成了。`Prim`算法的本质是基于贪心算法（greedy algorithm）。

`Prim`算法可以理解为让一棵小树长大，每次找能够向外生长的最小边。

例如使用`Prim`算法获得一个带权图的最小生成树：

![](./img/C8/8-6/3.png)



**Kruskal**

与`Prim`算法不同，`Prim`算法是以顶点为关键来获得最小生成树的，而`Kruskal`算法是以边为关键获得最小生成树的。

`Kruskal`算法可以理解为将森林合并成树，每次在图中找权值最小的边收录。

例如使用`Kruskal`算法获得一个带权图的最小生成树：

![](./img/C8/8-6/4.png)

<div style="page-break-after: always;"></div>

## 8.7 拓扑排序

**拓扑排序（Topological Sort）**

一项大的工程常被分为多个小的子工程，子工程之间可能存在一定的先后顺序，即某些子工程必须在其它的一些子工程完成后才能开始。在现代化管理中，有向图可以用来描述和分析一项工程的计划和实施过程，其中图的顶点表示活动，有向边表示活动之间的先后关系，这样的图称为`AOV（Activity on Vertex）`网。

```mermaid
graph LR
	A --> B
	B --> C
	B --> D
	B --> E
	C --> E
	D --> E
	E --> F
```

如果图中从顶点$ V $到$ W $有一条有向路径，则$ V $一定排在$ W $之前，满足此条件的顶点序列称为一个拓扑序。`AOV`网如果有合理的拓扑序，则必定是有向无环图（DAG, Directed Acyclic Graph）。

<img src="./img/C8/8-7/1.png" style="zoom:67%;" />

可以使用卡恩`Kahn`算法完成拓扑排序。假设列表$ L $用于存放拓扑排序的结果，把所有入度为`0`的顶点放入$ L $中，然后把这些顶点从图中去掉。重复该操作，直到找不到入度为`0`的顶点。如果此时$ L $中的元素个数和图的顶点总数相同，说明拓扑排序完成；如果此时$ L $中的元素个数少于图的顶点总数，说明原图中存在环，无法进行拓扑排序。

例如对计算机专业课安排学习顺序：

| 课程代码 |       课程名称       | 预修课程 |
| :------: | :------------------: | :------: |
|    C1    |     程序设计基础     |    无    |
|    C2    |       离散数学       |    无    |
|    C3    |       数据结构       |  C1、C2  |
|    C4    |     微积分（一）     |    无    |
|    C5    |     微积分（二）     |    C4    |
|    C6    |       线性代数       |    C5    |
|    C7    |    算法分析与设计    |    C3    |
|    C8    | 逻辑与计算机设计基础 |    无    |
|    C9    |      计算机组成      |    C8    |
|   C10    |       操作系统       |  C7、C9  |
|   C11    |       编译原理       |  C7、C9  |
|   C12    |        数据库        |    C7    |
|   C13    |       计算理论       |    C2    |
|   C14    |      计算机网络      |   C10    |
|   C15    |       数值分析       |    C6    |

```mermaid
graph LR
	C1 --> C3
	C2 --> C3
	C2 --> C13
	C3 --> C7
	C4 --> C5
	C5 --> C6
	C6 --> C15
	C7 --> C10
	C7 --> C11
	C7 --> C12
	C8 --> C9
	C9 --> C10
	C9 --> C11
	C10 --> C14
```

```mermaid
graph LR
	C3 --> C7
	C5 --> C6
	C6 --> C15
	C7 --> C10
	C7 --> C11
	C7 --> C12
	C9 --> C10
	C9 --> C11
	C10 --> C14
	C13

	subgraph SEMASTERS
		subgraph semaster 1
			C1/C2/C4/C8
		end
	end
```

```mermaid
graph LR
	C6 --> C15
	C7 --> C10
	C7 --> C11
	C7 --> C12
	C10 --> C14

	subgraph SEMASTERS
		subgraph semaster 1
			C1/C2/C4/C8
		end
		
		subgraph semaster 2
			C3/C5/C9/C13
		end
	end
```

```mermaid
graph LR
	C10 --> C14
	C11
	C12
	C15

	subgraph SEMASTERS
		subgraph semaster 1
			C1/C2/C4/C8
		end
		
		subgraph semaster 2
			C3/C5/C9/C13
		end
		
		subgraph semaster 3
			C6/C7
		end
	end
```

```mermaid
graph LR
	C14

	subgraph SEMASTERS
		subgraph semaster 1
			C1/C2/C4/C8
		end
		
		subgraph semaster 2
			C3/C5/C9/C13
		end
		
		subgraph semaster 3
			C6/C7
		end
		
		subgraph semaster 4
			C10/C11/C12/C15
		end
	end
```

```mermaid
graph LR
	subgraph SEMASTERS
		subgraph semaster 1
			C1/C2/C4/C8
		end
		
		subgraph semaster 2
			C3/C5/C9/C13
		end
		
		subgraph semaster 3
			C6/C7
		end
		
		subgraph semaster 4
			C10/C11/C12/C15
		end
		
		subgraph semaster 5
			C14
		end
	end
```

