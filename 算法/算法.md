# 第4章 贪心算法

## 4.1 贪心算法

**贪心算法（Greedy Algorithm）**

贪心算法，又称贪婪算法，是指在对问题求解时，总是做出在当前看来是最好的选择，也就是说不从整体最优上加以考虑。算法得到的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键在于贪心策略的选择。

贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。

在利用贪心算法求解问题之前，必须需要清楚什么样的问题适合用贪心算法。一般而言，能够利用贪心算法求解的问题都会具备以下两点性质：

1. 贪心选择：当某一个问题的整体最优解可通过一系列局部最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择。
2. 最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。

贪心算法的基本思路分为：

1. 建立数学模型描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每个子问题求解，得到子问题的局部最优解。
4. 把子问题的局部最优解合成为原问题的解。



**买卖股票的最佳时期**

给定一个数组，它的第$ i $个元素是一支给定股票第$ i $天的价格。设计一个算法来计算所能获取的最大利润。（提示：可以尽可能地完成更多的交易，但不能同时参与多笔交易，在再次购买前出售掉之前的股票）。

> 示例：
>
> 输入: [7, 1, 5, 3, 6, 4]
>
> 输出: 7
>
> 解释: 在第2天（股票价格 = 1）的时候买入，在第3天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。随后，在第4天（股票价格 = 3）的时候买入，在第5天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。

---

【代码】买卖股票的最佳时期

```java
public static int maxProfit(int[] prices) {
    int profit = 0;
    for(int i = 0; i < prices.length - 1; i++) {
        if(prices[i] < prices[i+1]) {
            profit += prices[i+1] - prices[i];
        }
    }
    return profit;
}
```

---



**分发饼干**

有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有大小。每个孩子最多只能吃一个饼干，且只有饼干的大小大于等于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。

> 示例1：
>
> 输入: children = [1, 2, 3], cookies = [1, 1]
>
> 输出: 1
>
> 解释: 有三个孩子和两块饼干，3个孩子的饥饿度分别是1, 2, 3。虽然有两块饼干，由于它们的大小都是1，只能让饥饿度是1的孩子满足。所以应该输出1。

> 示例2：
>
> 输入: children = [1, 2], cookies = [1, 2, 3]
>
> 输出: 2
>
> 解释: 有两个孩子和三块饼干，2个孩子的饥饿度分别是1, 2。拥有的饼干数量和大小都足以让所有孩子满足。所以应该输出2。

因为饥饿度最小的孩子最容易吃饱，所以先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。

这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。因为需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序，这样就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个孩子可以吃饱。

---

【代码】分发饼干

```java
public static int distribute(int[] children, int[] cookies) {
    Arrays.sort(children);
    Arrays.sort(cookies);
    int child = 0;
    int cookie = 0;
    while (child < children.length && cookie < cookies.length) {
        if (children[child] <= cookies[cookie++]) {
            child++;
        }
    }
    return child;
}
```

---



**硬币找零**

假设硬币的面值分别为1元、5元、10元、25元和100元，有一个小店拥有各面值硬币数量无限个，顾客买东西之后需要给顾客找零，如何能够使找零的硬币个数最少？

> 示例：
>
> 输入: 36输出: 3解释: 找零[25, 10, 1]

为了尽量减少硬币的数量，首先得尽可能地多使用面值大的硬币，也就是优先使用大面值的硬币。

---

【代码】硬币找零

```python
def get_min_coins(coins, price):
    """
        最少硬币找零
        Args:
            coins (list): 硬币面值
            price (int): 找零数量
    """
    solution = []
    coins = sorted(coins, reverse=True)
    for coin in coins:
        num = price // coin
        solution += [coin] * num
        price -= coin * num
        if price <= 0:
            break
    return solution
```

---

<div style="page-break-after: always;"></div>

## 4.2 活动安排

**活动安排**

假设有$ n $个活动的集合$ S = \{a_1, a_2, a_3, \dots, a_n\} $，其中每个活动都要使用同一种资源（如场馆等），而在同一时间内只能有一个活动使用这个资源。每个活动$ a_i $都有一个开始时间$ s_i $和结束时间$ f_i $（$ s_i < f_i $）。如果某个活动$ a_i $被选择，那么活动$ a_i $的发生时间在半开区间$ [s_i, f_i) $内。如果两个活动$ a_i $和$ a_j $满足$ [s_i, f_i) $和$ [s_j, f_j) $不重叠，则称它们是兼容的。活动安排问题就是要求选出最大兼容活动集。

假设活动已经按照结束时间的单调递增顺序排序好：

|  $ i $  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $ s_i $ |  1   |  3   |  0   |  5   |  3   |  5   |  6   |  8   |  8   |  2   |  12  |
| $ f_i $ |  4   |  5   |  6   |  7   |  9   |  9   |  10  |  11  |  12  |  14  |  16  |

对于活动安排问题的贪心选择，应该选择一个这样的活动，选择它之后剩下的资源可以被尽量多的其它活动所占用。活动安排问题中的贪心选择就是每次选择最先结束的活动。

一个贪心选择的日常应用场景就比如有多个不同的兼职岗位，每个岗位都有一个开始时间和结束时间，小灰在同一时间内只能做一份兼职，小灰每天最多可以做多少份兼职。面对这样的问题，在日常生活中，我们的第一选择肯定是先把结束时间早的兼职做了，这样就可以留出更多的时间做其它兼职。

---

【代码】活动安排

```java
public static List<Integer> selectActivity(int[] a, int[] s, int[] f) {
    List<Integer> activity = new ArrayList<Integer>();
    int n = s.length;
    activity.add(a[0]);
    int k = 0;
    for(int i = 1; i < n; i++) {
        if(s[i] >= f[k]) {
            activity.add(a[i]);
            k = i;
        }
    }
    return activity;
}
```

---

<div style="page-break-after: always;"></div>

## 4.3 部分背包

**部分背包（Knapsack）**

假设有一个小偷，背着一个容量为$ c $的背包（最多可以放的物品重量不能超过$ c $）。商店中一共有$ n $种物品，每种物品i的重量和价值分别为$ w_i $和$ v_i $。如何选择物品放入背包才能使得总价值最大？

![](./img/C4/4-3/1.png)

假设背包的容量为30，各类物品对应的重量和价格如下：

|   物品$ i $   |  1   |  2   |  3   |  4   |  5   |
| :-----------: | :--: | :--: | :--: | :--: | :--: |
| **重量$ w $** |  10  |  5   |  15  |  10  |  20  |
| **价值$ v $** |  20  |  30  |  15  |  25  |  10  |

对于背包问题，很显然它是满足最优子结构性质的，因为一个容量为$ c $的背包问题必然包含容量小于$ c $的背包问题的最优解。如果要使最终的价值最大，那么必定需要使得选择的单位中联的物品的价值最大。所以背包问题的贪心策略是优先选择单位重量价值最大的物品，当这个物品选择完之后，继续选择其它价值最大的物品。

---

【代码】部分背包

```python
class Item:
    """
        物品类
    """
    def __init__(self, type, weight, value):
        """
            初始化物品
            Args:
                type (int): 物品类型
                weight (float): 重量
                value (float): 价值
        """
        self.type = type
        self.weight = weight
        self.value = value
        self.unit_value = value / weight    # 单位价值

def main():
    capacity = 30       # 背包容量
    item_type = [1, 2, 3, 4, 5]
    item_weight = [10, 5, 15, 10, 30]
    item_value = [20, 30, 15, 25, 10]

    items = []
    for i in range(len(item_type)):
        items.append(Item(item_type[i], item_weight[i], item_value[i]))
    
    # 物品按照单价降序排列
    items.sort(key=lambda x: x.unit_value, reverse=True)

    # 背包选择
    selected_items = []
    cur_weight = 0          # 当前背包重量
    for item in items:
        if cur_weight + item.weight <= capacity:
            cur_weight += item.weight
            selected_items.append(item)
        else:
            item.weight = capacity - cur_weight
            selected_items.append(item)
            break
    
    # 输出选择结果
    for item in selected_items:
        print("类型：%d，重量：%.2f" % (item.type, item.weight))

if __name__ == "__main__":
    main()
```

---

<div style="page-break-after: always;"></div>

## 4.7 贪心算法局限性

**局限性**

贪心算法可以用来解决优化问题，与其他算法相比，贪心算法的最大优点是在大多数情况下易于实现且非常高效，但也存在一些问题。

贪心算法不能保证解是最佳的，因为它总是从局部出发，并没从整体考虑。尽管贪心算法给出了接近最优的解决方案，但它未能产生最优的解决方案。背包问题和旅行商问题是贪心算法无法产生最佳解决方案的问题示例。

当需要实时解决方案且近似答案足够好时，贪心算法最适用。显然，贪心算法可在确保产生最佳解决方案的同时最大程度地减少时间，因此更适用于需要较少时间的情况。



**硬币找零**

假设有1元、5元、11元这三种面值的硬币，给定一个找零金额，比如28元，最少使用的硬币组合是什么？

使用贪心算法可以得到结果为$ [11, 11, 5, 1] $，总共是4个硬币。对于这个例子而言，4个硬币的确是最优解。但是假如找零是15元呢？使用贪心算法结果为$ [11, 1, 1, 1, 1] $，共用了5个硬币，然而最优解是[5, 5, 5]，共3个硬币。硬币找零问题可以使用动态规划计算出最优解。



**0-1背包**

部分背包问题可以用贪心算法实现，是因为选择放入的物品可以进行拆分，即并不需要放入整个物品。与之对应的另一种背包问题为0-1背包问题，这个时候整个物品不可以拆分，只可以选择放入或者不放入。0-1背包问题用贪心算法并不能求得准确的解，需要用动态规划算法求解。

假设0-1背包的容量为8，物品的重量和价值分别为：

|   物品$ i $   |  1   |  2   |  3   |  4   |
| :-----------: | :--: | :--: | :--: | :--: |
| **重量$ w $** |  2   |  3   |  4   |  5   |
| **价值$ v $** |  3   |  4   |  5   |  6   |
| **单位价值**  | 1.5  | 1.33 | 1.25 | 1.2  |

使用贪心算法会优先选择单位重量价值最高的物品，当拿完物品1和物品2后，背包剩余容量为$ 8 - 2 - 3 = 3 $。由于物品不可拆分，背包无法装入物品3和物品4。最终总价值为$ 3 + 4 = 7 $。

但是使用动态规划可以计算出最佳方案是选择物品2和物品4，最大价值为$ 4 + 6 = 10 $。

<div style="page-break-after: always;"></div>

# 第5章 动态规划

## 5.1 动态规划

**动态规划（Dynamic Programming）**

动态规划在数学上属于运筹学的分支，是求解决策过程最优化的数学方法，同时也是计算机科学与技术领域中一种常见的算法思想。

动态规划算法的基本思想与分治法类似，也是将带求解的问题分解为若干个子问题，按顺序求解子问题。前一子问题的解，为后一子问题的求解提供了有用的信息。

在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其它局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

动态规划的本质是对问题状态的定义和状态转移方程的定义。动态规划通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推的方式去解决。因此在一个典型的动态规划问题上，需要定义问题状态以及写出状态转移方程，这样对于问题的解答就会一目了然。



**爬楼梯**

有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶，要求求出一共有多少种走法。

比如，每次走1级台阶，一共走10步，这是其中一种走法，可以简写成$ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] $。再比如，每次走2级台阶，一共走5步，这是另一种走法，可以简写成$ [2, 2, 2, 2, 2] $。当然，除此之外，还有很多很多种走法。

<img src="./img/C5/5-1/1.png" style="zoom:50%;" />

<img src="./img/C5/5-1/2.png" style="zoom:50%;" />

<img src="./img/C5/5-1/3.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/4.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/5.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/6.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/7.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/8.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/9.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/10.png" style="zoom:50%;" />

<img src="./img/C5/5-1/11.png" style="zoom:50%;" />

<img src="./img/C5/5-1/12.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/13.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/14.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/15.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/16.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/17.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/18.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/19.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/20.png" style="zoom: 80%;" />
$$
f(n) = \left\{
\begin{aligned}
& 1 & n = 1 \\
& 1 & n = 2 \\
& f(n-1) + f(n-2) & n \ge 3
\end{aligned}
\right.
$$

<img src="./img/C5/5-1/21.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/22.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/23.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/24.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/25.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/26.png" style="zoom: 80%;" />

---

【代码】爬楼梯（递归）

```c
int climbStairs(int n) {
    if(n <= 0) {
        return 0;
    } else if(n == 1) {
        return 1;
    } else if(n == 2) {
        return 2;
    }
    return climbStairs(n-1) + climbStairs(n-2);
}
```

---

<img src="./img/C5/5-1/27.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/28.png" style="zoom: 50%;" />

<img src="./img/C5/5-1/29.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/30.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/31.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/32.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/33.png" style="zoom: 50%;" />

<img src="./img/C5/5-1/34.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/35.png" style="zoom: 80%;" />

<img src="./img/C5/5-1/36.png" style="zoom: 80%;" />

|   台阶数   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **走法数** |  1   |  2   |      |      |      |      |      |      |      |

<img src="./img/C5/5-1/37.png" style="zoom: 80%;" />

|   台阶数   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **走法数** |  1   |  2   |  3   |      |      |      |      |      |      |

<img src="./img/C5/5-1/38.png" style="zoom: 80%;" />

|   台阶数   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **走法数** |  1   |  2   |  3   |  5   |      |      |      |      |      |

<img src="./img/C5/5-1/39.png" style="zoom: 80%;" />

|   台阶数   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **走法数** |  1   |  2   |  3   |  5   |  8   |      |      |      |      |

---

【代码】爬楼梯（动态规划）

```c
int climbStairs(int n) {
    if(n <= 0) {
        return 0;
    } else if(n == 1) {
        return 1;
    } else if(n == 2) {
        return 2;
    }
    int num1 = 1;
    int num2 = 2;
    int sum;
    for(int i = 3; i <= n; i++) {
        sum = num1 + num2;
        num1 = num2;
        num2 = sum;
    }
    return sum;
}
```

---

<div style="page-break-after: always;"></div>

## 5.2 硬币找零

**硬币找零**

有三种硬币，面值分别是2元、5元、7元，每种硬币都有足够多。买一个物品需要27元，如何用最少的硬币组合正好付清？

![](./img/C5/5-2/1.png)

要让硬币最少，应该尽量用面值大的硬币，也就是贪心算法的结果为$ 7 + 7 + 7 + 5 = 26 $，呃……

那么需要改变一下策略，尽量用面值大的硬币，最后如果可以用一种硬币付清就行。$ 7 + 7 + 7 + 2 + 2 + 2 = 27 $，一共$ 6 $枚硬币，应该对了吧……

正确答案：$ 7 + 5 + 5 + 5 + 5 = 27 $，一共$ 5 $枚硬币。

状态在动态规划中的作用属于定海神针，确定状态需要两个意识：

1. 最后一步：虽然目前不知道最优策略是什么，但是最优策略肯定是$ k $枚硬币$ a_1, a_2, \dots, a_K $面值加起来是$ 27 $。所以一定有最后一枚硬币$ a_k $除了这枚硬币，前面硬币的面值加起来是$ 27 - a_k $。因为是最优策略，所以拼出$ 27 - a_k $的硬币数一定要最少。

<img src="./img/C5/5-2/2.png" style="zoom: 50%;" />

2. 子问题：因此问题就变成了最少用多少枚硬币可以拼出$ 27 - a_k $。这样就将原问题转化成了一个子问题，而且规模更小。

假设状态$ F(X) = 拼出X元的最少硬币数 $，

最后那枚硬币$ a_k $只可能是$ 2 $元、$ 5 $元或$ 7 $元：

- 如果$ a_k $是$ 2 $元，$ F(27) = F(27-2) + 1 $（加上最后一枚$ 2 $元硬币）
- 如果$ a_k $是$ 5 $元，$ F(27) = F(27-5) + 1 $（加上最后一枚$ 5 $元硬币）
- 如果$ a_k $是$ 7 $元，$ F(27) = F(27-7) + 1 $（加上最后一枚$ 7 $元硬币）

由此可得到递归公式：
$$
F(27) = min\{F(27-2)+1,\ F(27-5)+1,\ F(27-7)+1\}
$$

---

【代码】硬币找零（递归）

```java
public static int getMinCoins(int price) {
    // 0元钱只需要0枚硬币
    if(price == 0) {
        return 0;
    }
    // 初始化为无穷大
    int coinNum = Integer.MAX_VALUE - 1;
    // 最后一枚硬币是2元
    if(price >= 2) {
        coinNum = Math.min(getMinCoins(price-2) + 1, coinNum);
    }
    // 最后一枚硬币是5元
    if(price >= 5) {
        coinNum = Math.min(getMinCoins(price-5) + 1, coinNum);
    }
    // 最后一枚硬币是7元
    if(price >= 7) {
        coinNum = Math.min(getMinCoins(price-7) + 1, coinNum);
    }
    return coinNum;
}
```

---

<img src="./img/C5/5-2/3.png" style="zoom: 50%;" />

动态规划的另一个组成部分就是状态转移方程：
$$
F[X] = min\{F[X-2]+1,\ F[X-5]+1,\ F[X-7]+1\}
$$
其次需要考虑初始条件和边界情况：如果不能拼出$ i $元，则定义$ F[i] = \infin $。例如当$ X - 2 $、$ X - 5 $、$ X - 7 $小于$ 0 $，
$$
F[-1] = F[-2] = \dots = \infin
$$
因此，
$$
F[1] = min\{F[-1]+1,\ F[-4]+1,\ F[-6]+1\} = \infin
$$
表示拼不出$ 1 $元。

状态转移方程的初始状态为
$$
F[0] = 0
$$
<img src="./img/C5/5-2/4.png" style="zoom: 50%;" />

<img src="./img/C5/5-2/4.png" style="zoom: 50%;" />

<img src="./img/C5/5-2/6.png" style="zoom: 50%;" />

<img src="./img/C5/5-2/7.png" style="zoom: 50%;" />

<img src="./img/C5/5-2/8.png" style="zoom: 50%;" />

---

【代码】硬币找零（动态规划）

```python
def get_min_coins(coins, price):
    f = [INF] * (price + 1)

    f[0] = 0
    for i in range(1, price+1):
        for j in range(len(coins)):
            if i >= coins[j] and f[i - coins[j]] != INF:
                f[i] = min(f[i - coins[j]] + 1, f[i])
        
    if f[price] == INF:
        f[price] = -1
    return f[price]
```

---

<div style="page-break-after: always;"></div>

## 5.3 路径问题

**路径问题**

有一个机器人位于一个$ m $行$ n $列的网格的左上角$ (0, 0) $，机器人每次只能向下或向右移动一步，问有多少种方法可以走到右下角。

<img src="./img/C5/5-3/1.png" style="zoom: 50%;" />

<img src="./img/C5/5-3/2.png" style="zoom: 50%;" />

无论机器人用何种方式到达右下角，总有最后挪动的一步。右下角的坐标为$ (m-1, n-1) $，那么前一步机器人一定在$ (m-2, n-1) $或$ (m-1, n-2) $的位置。

如果机器人有$ X $种方式从左上角走到$ (m-2, n-1) $，有$ Y $种方式从左上角走到$ (m-1, n-2) $，那么机器人一共有$ X + Y $种方式从左上角走到$ (m-1, n-1) $。原问题就转换为了机器人有多少种方式从左上角走到$ (m-2, n-1) $和$ (m-1, n-2) $。

那么可以得出转移方程：
$$
f[i][j] = f[i-1][j] + f[i][j-1]
$$

> $ f[i][j] $：机器人有多少种方式走到$ (i, j) $
>
> $ f[i-1][j] $：机器人有多少种方式走到$ (i-1, j) $
>
> $ f[i][j-1] $：机器人有多少种方式走到$ (i, j-1) $

初始条件为$ f[0][0] = 1 $，因为机器人只有$ 1 $种方式到达左上角。

边界情况为当$ i = 0 $或$ j = 0 $，则前一步只能有一个方向到达，因此$ f[i][j] = 1 $。

<img src="./img/C5/5-3/3.png" style="zoom: 50%;" />

---

【代码】路径问题

```c
int uniquePath(int m, int n) {
    int f[m][n];
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            if(i == 0 || j == 0) {
                f[i][j] = 1;
            } else {
                f[i][j] = f[i-1][j] + f[i][j-1];
            }
        }
    }
    return f[m-1][n-1];
}
```

---

<div style="page-break-after: always;"></div>

## 5.4 跳跃游戏

**跳跃游戏**

有$ n $块石头分别在$ 0, 1, \dots, n-1 $的位置，一只青蛙在石头$ 0 $，想跳到石头$ n - 1 $。如果青蛙在第i块石头上，每块石头的元素表示可以跳跃的最长距离。问青蛙能否跳到石头$ n - 1 $。

> 示例1：
>
> 输入: s = [2, 3, 1, 1, 4]
>
> 输出: True
>
> 解释: 可以先跳1步，从石头0达到石头1，然后再从石头1跳3步到达目标。

> 示例2：
>
> 输入: s = [3, 2, 1, 0, 4]
>
> 输出: False
>
> 解释: 无论怎样，总会达到石头3，但该石头的最大跳跃长度是0，所以永远不可能到达目标。

如果青蛙能跳到最后一块石头$ n - 1 $，那么它一定是从石头$ i $跳过来的（$ i < n - 1 $）。

这需要两个条件同时满足：

1. 青蛙可以跳到石头$ i $。
2. 最后一跳不超过跳跃的最大距离。

![](./img/C5/5-4/1.png)

那么问题转化为了青蛙能否跳到石头$ i $。假设$ f[j] $表示青蛙能否跳到石头$ j $，可以得出转移方程：
$$
f[j] = OR_{0 \le i < j}(f[i]\ AND\ i + a[i] \ge j)
$$

> $ f[j] $：青蛙能否跳到石头$ j $
>
> $ OR_{0 \le i < j} $：枚举上一个跳到的石头$ i $
>
> $ f[i] $：青蛙能否跳到石头$ i $
>
> $ a[i] $：最后一步的距离不能超过$ a_i $

初始条件为$ f[0] = True  $，因为青蛙一开始就在石头$ 0 $。

---

【代码】跳跃游戏

```java
public static boolean canJump(int[] stone) {
    int n = stone.length;
    boolean[] f = new boolean[n];
    f[0] = true;

    for(int j = 1; j < n; j++) {
        f[j] = false;
        for(int i = 0; i < j; i++) {
            if(f[i] && i + stone[i] >= j) {
                f[j] = true;
                break;
            }
        }
    }
    return f[n-1];
}
```

---

<div style="page-break-after: always;"></div>

## 5.5 0-1背包

**0-1背包（0-1 Knapsack）**

有一个小偷带了一个能够装$ C = 20 $公斤物品的背包到商店里面偷东西，请问他要怎么偷才能使价值最高？

| 物品 | 重量W | 价格V |
| :--: | :---: | :---: |
|  0   |   2   |   3   |
|  1   |   3   |   4   |
|  2   |   4   |   5   |
|  3   |   5   |   8   |
|  4   |   9   |  10   |

假设用$ B(k, C) $表示当背包容量还剩下$ C $的时候，在前$ k $件物品中能偷到的最大价值。
$$
B(k, C) = \left\{
\begin{aligned}
& B(k-1, C) & \text{当第}k\text{件太重} \\
& max \left\{
        \begin{aligned}
        & B(k-1, C-w_k) + v_k & \text{偷} \\
        & B(k-1, C)	& \text{不偷} \\
        \end{aligned}
	\right.
\end{aligned}
\right.
$$
<img src="./img/C5/5-5/1.png" style="zoom:67%;" />

边界情况为$ B(i, 0)  = B(0, j) = 0 $，即当背包容量为$ 0 $或者没有物品可偷的情况下，最大价值为$ 0 $。 

<img src="./img/C5/5-5/2.png"  />

---

【代码】0-1背包

```c
#define ITEM_NUM 5
#define CAPACITY 20

int getMaxValue(int *weight, int *value) {
    int b[ITEM_NUM+1][CAPACITY+1] = {{0}};

    for(int k = 1; k <= ITEM_NUM; k++) {
        for(int c = 1; c <= CAPACITY; c++) {
            if(weight[k] > c) {
                b[k][c] = b[k-1][c];
            } else {
                b[k][c] = max(
                    b[k-1][c-weight[k]] + value[k],
                    b[k-1][c]
               	);
            }
        }
    }
    return b[ITEM_NUM][CAPACITY];
}
```